
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Step 1: Adding Value with Custom Docker Images Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="step2.html" />
    
    
    <link rel="prev" href="lab2.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        <li class="header">docker101 lab</li>
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../lab0.md">
            
                <span>
            
                    
                    Install Docker
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../lab1/lab1.html">
            
                <a href="../lab1/lab1.html">
            
                    
                    Run your first container
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../lab1/step1.html">
            
                <a href="../lab1/step1.html">
            
                    
                    Step 1: Run your first container
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../lab1/step2.html">
            
                <a href="../lab1/step2.html">
            
                    
                    Step 2: Run Multiple Containers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="../lab1/step3.html">
            
                <a href="../lab1/step3.html">
            
                    
                    Step 2: Clean Up
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="lab2.html">
            
                <a href="lab2.html">
            
                    
                    Add value with custom images
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter active" data-level="1.4.1" data-path="step1.html">
            
                <a href="step1.html">
            
                    
                    Step 1: Adding Value with Custom Docker Images
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="step2.html">
            
                <a href="step2.html">
            
                    
                    Step 2: Create and build the Docker Image
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="step3.html">
            
                <a href="step3.html">
            
                    
                    Step 3: Run the Docker image
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="step4.html">
            
                <a href="step4.html">
            
                    
                    Step 4: Deploying a Change
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Step 1: Adding Value with Custom Docker Images</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="lab-2--adding-value-with-custom-docker-images">Lab 2- Adding Value with Custom Docker Images</h1>
<h2 id="overview">Overview</h2>
<p>In this lab, we will create a custom Docker Image built from a Dockerfile. Once we build the image, we will push it to a central registry where it can be pulled to be deployed on other environments. Also, we will briefly describe image layers, and how Docker incorporates &quot;copy-on-write&quot; and the union file system to efficiently store images and run containers.</p>
<p>We will be using a few Docker commands in this lab. For full documentation on available commands check out the <a href="https://docs.docker.com/" target="_blank">official documentation</a>.</p>
<h2 id="prerequisites">Prerequisites</h2>
<p>You must have access to an environment with docker installed, such as a provided wetty environment through a workshop.</p>
<h3 id="login-to-docker-hub">Login to Docker Hub</h3>
<ol>
<li><p>Navigate to <a href="https://hub.docker.com" target="_blank">https://hub.docker.com</a> and create an account if you haven&apos;t already</p>
<p> For this lab we will be using the docker hub as our central registry. Docker hub is a free service to store publicly available images, or you can pay to store private images. Go to the <a href="https://hub.docker.com" target="_blank">DockerHub</a> website and create a free account.</p>
<p> Most organizations that use docker heavily will set up their own registry internally. To simplify things, we will be using the Docker Hub, but the following concepts apply to any registry.</p>
</li>
<li><p>Save your DockerHub username into a variable, so that you can copy/paste the rest of the commands for this lab. Replace the command below with your username.</p>
<pre><code class="lang-sh"> $ <span class="hljs-built_in">export</span> DOCKER_USER=[docker username]
</code></pre>
</li>
<li><p>Login</p>
<p> You can log into the docker registry account by typing <code>docker login</code> on your terminal.</p>
<pre><code class="lang-sh"> $ docker login -u <span class="hljs-variable">$DOCKER_USER</span>
 Password:
</code></pre>
</li>
</ol>
<h2 id="step-1-create-a-python-app-without-using-docker">Step 1: Create a python app (without using Docker)</h2>
<ol>
<li><p>Create a folder for this project, If you are using a cloud shell use:</p>
<pre><code class="lang-sh"> $ mkdir myapp
 $ <span class="hljs-built_in">cd</span> myapp
</code></pre>
</li>
<li><p>Run the following command to create a file named <code>app.py</code> with a simple python program. (copy-paste the entire code block)</p>
<pre><code class="lang-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&apos;from flask import Flask

 app = Flask(__name__)

 @app.route(&quot;/&quot;)
 def hello():
     return &quot;hello world!&quot;

 if __name__ == &quot;__main__&quot;:
     app.run(host=&quot;0.0.0.0&quot;)&apos;</span> &gt; app.py
</code></pre>
<p> This is a simple python app that uses flask to expose a http web server on port 5000 (5000 is the default port for flask). Don&apos;t worry if you are not too familiar with python or flask, these concepts can be applied to an application written in any language.</p>
</li>
</ol>
<h2 id="step-2-create-and-build-the-docker-image">Step 2: Create and build the Docker Image</h2>
<p>If you don&apos;t have python install locally, don&apos;t worry! Because you don&apos;t need it. One of the advantages of using Docker containers is that you can build python into your containers, without having python installed on your host. </p>
<ol>
<li><p>Create a <code>Dockerfile</code> but running the following command. (copy-paste the entire code block)</p>
<pre><code class="lang-sh"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&apos;FROM python:3.6.1-alpine
 RUN pip install flask
 CMD [&quot;python&quot;,&quot;app.py&quot;]
 COPY app.py /app.py&apos;</span> &gt; Dockerfile
</code></pre>
<p> A Dockerfile lists the instructions needed to build a docker image. Let&apos;s go through the above file line by line.</p>
<p> <strong>FROM python:3.6.1-alpine</strong></p>
<p> This is the starting point for your Dockerfile. Every Dockerfile must start with a <code>FROM</code> line that is the starting image to build your layers on top of. In this case, we are selecting the <code>python:3.6.1-alpine</code> base layer since it already has the version of python and pip that we need to run our application. The <code>alpine</code> version means that it uses the alpine distribution, which is significantly smaller than an alternative flavor of linux. A smaller image means it will download (deploy) much faster, and it also has advantages for security because it has a smaller attack surface.</p>
<p> Here we are using the &quot;3.6.1-alpine&quot; tag for the python image. Take a look at the available tags for the official python image on the <a href="https://hub.docker.com/_/python/" target="_blank">Docker Hub</a>. It is best practice to use a specific tag when inheriting a parent image so that changes to the parent dependency are controlled. If no tag is specified, the &quot;latest&quot; tag takes into effect, which is acts as a dynamic pointer that points to the latest version of an image. </p>
<p> For security reasons, it is very important to understand the layers that you build your docker image on top of. For that reason, it is highly recommended to only use &quot;official&quot; images found in the <a href="https://hub.docker.com/" target="_blank">docker hub</a>, or non-community images found in the docker-store. These images are <a href="https://docs.docker.com/docker-hub/official_repos/" target="_blank">vetted</a> to meet certain security requirements, and also have very good documentation for users to follow. You can find more information about this <a href="https://store.docker.com/images/python" target="_blank">python base image</a>, as well as all other images that you can use, on the <a href="https://store.docker.com/" target="_blank">docker store</a>.</p>
<p> For a more complex application you may find the need to use a<code>FROM</code> image that is higher up the chain. For example, the parent <a href="https://github.com/docker-library/python/blob/88ba87d31a3033d4dbefecf44ce25aa1b69ab3e5/3.6/alpine/Dockerfile" target="_blank">Dockerfile</a> for our python app  starts with <code>FROM alpine</code>, then specifies a series of <code>CMD</code> and <code>RUN</code> commands for the image. If you needed more fine-grained control, you could start with <code>FROM alpine</code> (or a different distribution) and run those steps yourself. To start off though, I recommend using an official image that closely matches your needs.</p>
<p> <strong>RUN pip install flask</strong></p>
<p> The <code>RUN</code> command executes commands needed to set up your image for your application, such as installing packages, editing files, or changing file permissions. In this case we are installing flask. The <code>RUN</code> commands are executed at build time, and are added to the layers of your image. </p>
<p> <strong>CMD [&quot;python&quot;,&quot;app.py&quot;]</strong></p>
<p> <code>CMD</code> is the command that is executed when you start a container. Here we are using <code>CMD</code> to run our python app. </p>
<p> There can be only one <code>CMD</code> per Dockerfile. If you specify more thane one <code>CMD</code>, then the last <code>CMD</code> will take effect. The parent python:3.6.1-alpine also specifies a <code>CMD</code> (<code>CMD python2</code>). You can find the Dockerfile for the official python:alpine image (here) [<a href="https://github.com/docker-library/python/blob/88ba87d31a3033d4dbefecf44ce25aa1b69ab3e5/3.6/alpine/Dockerfile" target="_blank">https://github.com/docker-library/python/blob/88ba87d31a3033d4dbefecf44ce25aa1b69ab3e5/3.6/alpine/Dockerfile</a>]. </p>
<p> You can use the official python image directly to run python scripts without installing python on your host. But today, we are creating a custom image to include our source, so that we can build an image with our application and ship it around to other environments.</p>
<p> <strong>COPY app.py /app.py</strong></p>
<p> This copies the app.py in the local directory (where you will run <code>docker image build</code>) into a new layer of the image. This instruction is the last line in the Dockerfile. Layers that change frequently, such as copying source code into the image, should be placed near the bottom of the file to take full advantage of the Docker layer cache. This allows us to avoid rebuilding layers that could otherwise be cached. For instance, if there was a change in the <code>FROM</code> instruction, it would invalidate the cache for all subsequent layers of this image. We will demonstrate a this little later in this lab.</p>
<p> It seems counter-intuitive to put this after the <code>CMD [&quot;python&quot;,&quot;app.py&quot;]</code> line. Remember, the <code>CMD</code> line is executed only when the container is started, so we won&apos;t get a <code>file not found</code> error here. </p>
<p> And there you have it: a very simple Dockerfile. A full list of commands you can put into a Dockerfile can be found <a href="https://docs.docker.com/engine/reference/builder/" target="_blank">here</a>. Now that we defined our Dockerfile, let&apos;s use it to build our custom docker image.</p>
</li>
<li><p>Build the docker image. </p>
<p> Pass in <code>-t</code> to name your image <code>$DOCKER_USER/python-hello-world</code>, with the tag <code>v1</code> to indicate this is the first version of the image</p>
<pre><code class="lang-sh"> $ docker image build -t <span class="hljs-variable">$DOCKER_USER</span>/python-hello-world:v1 .
 Sending build context to Docker daemon  3.072kB
 Step 1/4 : FROM python:3.6.1-alpine
 3.6.1-alpine: Pulling from library/python
 acb474fa8956: Pull complete 
 967ab02d1ea4: Pull complete 
 640064d26350: Pull complete 
 db0225fcac8f: Pull complete 
 5432cc692c60: Pull complete 
 Digest: sha256:768360b3fad01adffcf5ad9eccb4aa3ccc83bb0ed341bbdc45951e89335082ce
 Status: Downloaded newer image <span class="hljs-keyword">for</span> python:3.6.1-alpine
  ---&gt; c86415c03c37
 Step 2/4 : RUN pip install flask
 ---&gt; Running <span class="hljs-keyword">in</span> cac3222673a3
 Collecting flask
  Downloading Flask-0.12.2-py2.py3-none-any.whl (83kB)
 Collecting itsdangerous&gt;=0.21 (from flask)
   Downloading itsdangerous-0.24.tar.gz (46kB)
 Collecting click&gt;=2.0 (from flask)
   Downloading click-6.7-py2.py3-none-any.whl (71kB)
 Collecting Werkzeug&gt;=0.7 (from flask)
   Downloading Werkzeug-0.12.2-py2.py3-none-any.whl (312kB)
 Collecting Jinja2&gt;=2.4 (from flask)
   Downloading Jinja2-2.9.6-py2.py3-none-any.whl (340kB)
 Collecting MarkupSafe&gt;=0.23 (from Jinja2&gt;=2.4-&gt;flask)
   Downloading MarkupSafe-1.0.tar.gz
 Building wheels <span class="hljs-keyword">for</span> collected packages: itsdangerous, MarkupSafe
  Running setup.py bdist_wheel <span class="hljs-keyword">for</span> itsdangerous: started
  Running setup.py bdist_wheel <span class="hljs-keyword">for</span> itsdangerous: finished with status <span class="hljs-string">&apos;done&apos;</span>
  Stored <span class="hljs-keyword">in</span> directory: /root/.cache/pip/wheels/<span class="hljs-built_in">fc</span>/a8/66/24d655233c757e178d45dea2de22a04c6d92766abfb741129a
  Running setup.py bdist_wheel <span class="hljs-keyword">for</span> MarkupSafe: started
  Running setup.py bdist_wheel <span class="hljs-keyword">for</span> MarkupSafe: finished with status <span class="hljs-string">&apos;done&apos;</span>
  Stored <span class="hljs-keyword">in</span> directory: /root/.cache/pip/wheels/88/a7/30/e39a54a87bcbe25308fa3ca64e8ddc75d9b3e5afa21ee32d57
 Successfully built itsdangerous MarkupSafe
 Installing collected packages: itsdangerous, click, Werkzeug, MarkupSafe, Jinja2, flask
 Successfully installed Jinja2-2.9.6 MarkupSafe-1.0 Werkzeug-0.12.2 click-6.7 flask-0.12.2 itsdangerous-0.24
 ---&gt; ce41f2517c16
 Removing intermediate container cac3222673a3
 Step 3/4 : CMD python app.py
 ---&gt; Running <span class="hljs-keyword">in</span> 2197e5263eff
 ---&gt; 0ab91286958b
 Removing intermediate container 2197e5263eff
 Step 4/4 : COPY app.py /app.py
 ---&gt; f1b2781b3111
 Removing intermediate container b92b506ee093
 Successfully built f1b2781b3111
 Successfully tagged python-hello-world:latest
</code></pre>
<p> Verify that your image shows up in your image list via <code>docker image ls | grep $DOCKER_USEr</code>.</p>
<pre><code class="lang-sh"> $ docker image ls | grep <span class="hljs-variable">$DOCKER_USER</span>
 jzaccone/python-hello-world                                                                                                                                       v1                  7feaf028e337        9 seconds ago       98.7MB
</code></pre>
</li>
</ol>
<h2 id="step-3-run-the-docker-image">Step 3: Run the Docker image</h2>
<p>Now that you have built the image, you can run it to see that it works.</p>
<ol>
<li><p>Run the Docker image</p>
<pre><code class="lang-sh"> $ docker run --name python-<span class="hljs-variable">$DOCKER_USER</span> -p 5000:5000 <span class="hljs-_">-d</span> <span class="hljs-variable">$DOCKER_USER</span>/python-hello-world:v1
 0b2ba61df37fb4038d9ae5d145740c63c2c211ae2729<span class="hljs-built_in">fc</span>27dc01b82b5aaafa26
</code></pre>
<p> The <code>-p</code> flag maps a port running inside the container to your host. In this case, we are mapping the python app running on port 5000 inside the container, to an external port on your host.</p>
</li>
<li><p>curl <code>http://localhost:5000</code> to see the results. </p>
<pre><code class="lang-sh"> $ curl http://localhost:5000
 hello world
</code></pre>
<p> You should see &quot;hello world!&quot; in your terminal.</p>
</li>
<li><p>Check the log output of the container.</p>
<p> If you want to see logs from your application you can use the <code>docker container logs</code> command. By default, <code>docker container logs</code> prints out what is sent to standard out by your application. Use <code>docker container ls</code> to find the id for your running container.</p>
<pre><code class="lang-sh"> $ docker container logs python-<span class="hljs-variable">$DOCKER_USER</span> 
 * Serving Flask app <span class="hljs-string">&quot;app&quot;</span> (lazy loading)
 * Environment: production
   WARNING: This is a development server. Do not use it <span class="hljs-keyword">in</span> a production deployment.
    Use a production WSGI server instead.
  * Debug mode: off
  * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)
 172.17.0.1 - - [30/Jul/2019 02:02:46] <span class="hljs-string">&quot;GET / HTTP/1.1&quot;</span> 200
</code></pre>
</li>
<li><p>Finally, clean up your image</p>
<pre><code class="lang-sh"> $ docker container rm <span class="hljs-_">-f</span> python-<span class="hljs-variable">$DOCKER_USER</span>
</code></pre>
<p> The Dockerfile is how you create reproducible builds for your application. A common workflow is to have your CI/CD automation run <code>docker image build</code> as part of its build process. Once images are built, they will be sent to a central registry, where it can be accessed by all environments (such as a test environment) that need to run instances of that application. In the next step, we will push our custom image to the public docker registry: the docker hub, where it can be consumed by other developers and operators.</p>
</li>
</ol>
<h2 id="step-4-push-to-a-central-registry">Step 4: Push to a central registry</h2>
<ol>
<li><p>Push your image to the Dockerhub registry</p>
<p> Once we have a properly tagged image, we can use the <code>docker push</code> command to push our image to the Docker Hub registry.</p>
<pre><code class="lang-sh"> $ docker push <span class="hljs-variable">$DOCKER_USER</span>/python-hello-world:v1
 The push refers to a repository [docker.io/jzaccone/python-hello-world]
 2bce026769ac: Pushed 
 64d445ecbe93: Pushed 
 18b27eac38a1: Mounted from library/python 
 3f6f25<span class="hljs-built_in">cd</span>8b1e: Mounted from library/python 
 b7af9d602a0f: Mounted from library/python 
 ed06208397d5: Mounted from library/python 
 5accac14015f: Mounted from library/python 
 latest: digest: sha256:508238f264616bf7bf962019d1a3826f8487ed6a48b80bf41fd3996c7175fd0f size: 1786
</code></pre>
<blockquote>
<p>Notice the &quot;Mounted from...&quot; entries, these are layers that are already in the registry. Only the new layers created in the image build are pushed to the Docker Hub registry.</p>
</blockquote>
</li>
<li><p>Check out your image on docker hub in your browser</p>
<p> Navigate to <a href="https://hub.docker.com" target="_blank">https://hub.docker.com</a> and go to your profile to see your newly uploaded image.</p>
<p> Now that your image is on Docker Hub, other developers and operations can use the <code>docker pull</code> command to deploy your image to other environments.  </p>
<p> <strong>Note:</strong> Docker images contain all the dependencies that it needs to run an application within the image. This is useful because we no longer have deal with environment drift (version differences) when we rely on dependencies that are install on every environment we deploy to. We also don&apos;t have to go through additional steps to provision these environments. Just one step: install docker, and you are good to go.</p>
</li>
</ol>
<h2 id="step-5-deploying-a-change">Step 5: Deploying a Change</h2>
<p>The &quot;hello world!&quot; application is overrated, let&apos;s update the app so that it says &quot;hello beautiful world&quot;.</p>
<ol>
<li><p>Update <code>app.py</code></p>
<p> Update the file with the following command. (copy-paste the entire code block)</p>
<pre><code class="lang-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&apos;from flask import Flask

 app = Flask(__name__)

 @app.route(&quot;/&quot;)
 def hello():
    return &quot;hello beautiful world!&quot;

 if __name__ == &quot;__main__&quot;:
     app.run(host=&quot;0.0.0.0&quot;)&apos;</span> &gt; app.py
</code></pre>
</li>
<li><p>Rebuild your image</p>
<p> Now that your app is updated, you need repeat the steps above to rebuild your app and push it to the Docker Hub registry.</p>
<pre><code class="lang-sh"> $  docker image build -t <span class="hljs-variable">$DOCKER_USER</span>/python-hello-world:v2 .
 Sending build context to Docker daemon  3.072kB
 Step 1/4 : FROM python:3.6.1-alpine
 ---&gt; c86415c03c37
 Step 2/4 : RUN pip install flask
  ---&gt; Using cache
  ---&gt; ce41f2517c16
 Step 3/4 : CMD python app.py
 ---&gt; Using cache
 ---&gt; 0ab91286958b
 Step 4/4 : COPY app.py /app.py
  ---&gt; 3e08b2eeace1
 Removing intermediate container 23a955e881<span class="hljs-built_in">fc</span>
 Successfully built 3e08b2eeace1
 Successfully tagged jzaccone/python-hello-world:latest
</code></pre>
<blockquote>
<p>Notice the &quot;Using cache&quot; for steps 1-3. These layers of the Docker Image have already been built and <code>docker image build</code> will use these layers from the cache instead of rebuilding them.</p>
</blockquote>
</li>
<li><p>Test your image locally. </p>
<pre><code class="lang-sh"> $ docker run -p 5000:5000 <span class="hljs-_">-d</span> <span class="hljs-variable">$DOCKER_USER</span>/python-hello-world:v2
 0b2ba61df37fb4038d9ae5d145740c63c2c211ae2729<span class="hljs-built_in">fc</span>27dc01b82b5aaafa26

 $ curl http://localhost:5000
 hello beatiful world!
</code></pre>
</li>
<li><p>Finally re-push your image to Docker Hub</p>
<pre><code class="lang-sh"> $ docker push <span class="hljs-variable">$DOCKER_USER</span>/python-hello-world:v2
 The push refers to a repository [docker.io/jzaccone/python-hello-world]
 94525867566e: Pushed 
 64d445ecbe93: Layer already exists 
 18b27eac38a1: Layer already exists 
 3f6f25<span class="hljs-built_in">cd</span>8b1e: Layer already exists 
 b7af9d602a0f: Layer already exists 
 ed06208397d5: Layer already exists 
 5accac14015f: Layer already exists 
 latest: digest: sha256:91874e88c14f217b4cab1dd5510da307bf7d9364bd39860c9cc8688573ab1a3a size: 1786
</code></pre>
<p>There is a caching mechanism in place for pushing layers too. Docker Hub already has all but one of the layers from an earlier push, so it only pushes the one layer that has changed.</p>
<p>When you change a layer, every layer built on top of that will have to be rebuilt. Each line in a Dockerfile builds a new layer that is built on the layer created from the lines before it. This is why the order of the lines in our Dockerfile is important. We optimized our Dockerfile so that the layer that is most likely to change (<code>COPY app.py /app.py</code>) is the last line of the Dockerfile. Generally for an application, your code changes at the most frequent rate. This optimization is particularly important for CI/CD processes, where you want your automation to run as fast as possible.</p>
</li>
</ol>
<h2 id="step-6-understanding-image-layers">Step 6: Understanding Image Layers</h2>
<p>One of the major design properties of Docker is its use of the union file system. </p>
<p>Consider the Dockerfile that we created before:</p>
<pre><code class="lang-sh">FROM python:3.6.1-alpine
RUN pip install flask
CMD [<span class="hljs-string">&quot;python&quot;</span>,<span class="hljs-string">&quot;app.py&quot;</span>]
COPY app.py /app.py
</code></pre>
<p>Each of these lines is a layer. Each layer contains only the delta, or changes from the layers before it. To put these layers together into a single running container, Docker makes use of the union file system to overlay layers transparently into a single view.</p>
<p>Each layer of the image is read-only, except for the very top layer which is created for the container. The read/write container layer implements &quot;copy-on-write&quot; which means that files that are stored in lower image layers are pulled up to the read/write container layer only when edits are being made to those files. Those changes are then stored in the container layer. The &quot;copy-on-write&quot; function is very fast, and in almost all cases, does not have a noticeable effect on performance. You can inspect which files have been pulled up to the container level with the <code>docker diff</code> command. More information about how to use <code>docker diff</code> can be found <a href="https://docs.docker.com/engine/reference/commandline/diff/" target="_blank">here</a> .</p>
<p><img src="images/lab2_understanding_image_layers_1.png" alt="Image Layers - thin rw layer"></p>
<p>Since image layers are read-only, they can be shared by images and by running containers. For instance, creating a new python app with its own Dockerfile with similar base layers, would share all the layers that it had in common with the first python app.</p>
<pre><code class="lang-sh">FROM python:3.6.1-alpine
RUN pip install flask
CMD [<span class="hljs-string">&quot;python&quot;</span>,<span class="hljs-string">&quot;app2.py&quot;</span>]
COPY app2.py /app2.py
</code></pre>
<p><img src="images/lab2_understanding_image_layers_2.png" alt="Image layers - sharing underlying layers"></p>
<p>You can also experience the sharing of layers when you start multiple containers from the same image. Since the containers use the same read-only layers, you can imagine that starting up containers is very fast and has a very low footprint on the host.</p>
<p>You may notice that there are duplicate lines in this Dockerfile and the Dockerfile you created earlier in this lab. Although this is a very trivial example, you can pull common lines of both Dockerfiles into a &quot;base&quot; Dockerfile, that you can then point to with each of your child Dockerfiles using the <code>FROM</code> command.</p>
<p>Image layering enables the docker caching mechanism for builds and pushes. For example, the output for your last <code>docker push</code> shows that some of the layers of your image already exists on the Docker Hub.</p>
<pre><code class="lang-sh">$ docker push <span class="hljs-variable">$DOCKER_USER</span>/python-hello-world
The push refers to a repository [docker.io/jzaccone/python-hello-world]
94525867566e: Pushed 
64d445ecbe93: Layer already exists 
18b27eac38a1: Layer already exists 
3f6f25<span class="hljs-built_in">cd</span>8b1e: Layer already exists 
b7af9d602a0f: Layer already exists 
ed06208397d5: Layer already exists 
5accac14015f: Layer already exists 
latest: digest: sha256:91874e88c14f217b4cab1dd5510da307bf7d9364bd39860c9cc8688573ab1a3a size: 1786
</code></pre>
<p>To look more closely at layers, you can use the <code>docker image history</code> command of the python image we created.</p>
<pre><code class="lang-sh">$ docker image <span class="hljs-built_in">history</span> <span class="hljs-variable">$DOCKER_USER</span>/python-hello-world:v1
IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
f1b2781b3111        5 minutes ago       /bin/sh -c <span class="hljs-comment">#(nop) COPY file:0114358808a1bb...   159B                </span>
0ab91286958b        5 minutes ago       /bin/sh -c <span class="hljs-comment">#(nop)  CMD [&quot;python&quot; &quot;app.py&quot;]      0B                  </span>
ce41f2517c16        5 minutes ago       /bin/sh -c pip install flask                    10.6MB              
c86415c03c37        8 days ago          /bin/sh -c <span class="hljs-comment">#(nop)  CMD [&quot;python3&quot;]              0B                  </span>
&lt;missing&gt;           8 days ago          /bin/sh -c <span class="hljs-built_in">set</span> -ex;   apk add --no-cache -...   5.73MB              
&lt;missing&gt;           8 days ago          /bin/sh -c <span class="hljs-comment">#(nop)  ENV PYTHON_PIP_VERSION=...   0B                  </span>
&lt;missing&gt;           8 days ago          /bin/sh -c <span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/bin  &amp;&amp; ln <span class="hljs-_">-s</span> idl...   32B                 
&lt;missing&gt;           8 days ago          /bin/sh -c <span class="hljs-built_in">set</span> -ex  &amp;&amp; apk add --no-cache ...   77.5MB              
&lt;missing&gt;           8 days ago          /bin/sh -c <span class="hljs-comment">#(nop)  ENV PYTHON_VERSION=3.6.1     0B                  </span>
&lt;missing&gt;           8 days ago          /bin/sh -c <span class="hljs-comment">#(nop)  ENV GPG_KEY=0D96DF4D411...   0B                  </span>
&lt;missing&gt;           8 days ago          /bin/sh -c apk add --no-cache ca-certificates   618kB               
&lt;missing&gt;           8 days ago          /bin/sh -c <span class="hljs-comment">#(nop)  ENV LANG=C.UTF-8             0B                  </span>
&lt;missing&gt;           8 days ago          /bin/sh -c <span class="hljs-comment">#(nop)  ENV PATH=/usr/local/bin...   0B                  </span>
&lt;missing&gt;           9 days ago          /bin/sh -c <span class="hljs-comment">#(nop)  CMD [&quot;/bin/sh&quot;]              0B                  </span>
&lt;missing&gt;           9 days ago          /bin/sh -c <span class="hljs-comment">#(nop) ADD file:cf1b74f7af8abcf...   4.81MB</span>
</code></pre>
<p>Each line represents a layer of the image. You&apos;ll notice that the top lines match to your Dockerfile that you created, and the lines below are pulled from the parent python image. Don&apos;t worry about the &quot;\<missing\>&quot; tags. These are still normal layers; they have just not been given an ID by the docker system.</missing\></p>
<h2 id="summary">Summary</h2>
<p>In this lab, you started adding value by creating your own custom docker containers. </p>
<p>Key Takeaways:</p>
<ul>
<li>The Dockerfile is how you create reproducible builds for your application and how you integrate your application with Docker into the CI/CD pipeline</li>
<li>Docker images can be made available to all of your environments through a central registry. The Docker Hub is one example of a registry, but you can deploy your own registry on servers you control.</li>
<li>Docker images contain all the dependencies that it needs to run an application within the image. This is useful because we no longer have deal with environment drift (version differences) when we rely on dependencies that are install on every environment we deploy to.</li>
<li>Docker makes use of the union file system and &quot;copy on write&quot; to reuse layers of images. This lowers the footprint of storing images and significantly increases the performance of starting containers.</li>
<li>Image layers are cached by the Docker build and push system. No need to rebuild or repush image layers that are already present on the desired system.</li>
<li>Each line in a Dockerfile creates a new layer, and because of the layer cache, the lines that change more frequently (e.g. adding source code to an image) should be listed near the bottom of the file.</li>
</ul>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="lab2.html" class="navigation navigation-prev " aria-label="Previous page: Add value with custom images">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="step2.html" class="navigation navigation-next " aria-label="Next page: Step 2: Create and build the Docker Image">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Step 1: Adding Value with Custom Docker Images","level":"1.4.1","depth":2,"next":{"title":"Step 2: Create and build the Docker Image","level":"1.4.2","depth":2,"path":"lab2/step2.md","ref":"lab2/step2.md","articles":[]},"previous":{"title":"Add value with custom images","level":"1.4","depth":1,"path":"lab2/lab2.md","ref":"lab2/lab2.md","articles":[{"title":"Step 1: Adding Value with Custom Docker Images","level":"1.4.1","depth":2,"path":"lab2/step1.md","ref":"lab2/step1.md","articles":[]},{"title":"Step 2: Create and build the Docker Image","level":"1.4.2","depth":2,"path":"lab2/step2.md","ref":"lab2/step2.md","articles":[]},{"title":"Step 3: Run the Docker image","level":"1.4.3","depth":2,"path":"lab2/step3.md","ref":"lab2/step3.md","articles":[]},{"title":"Step 4: Deploying a Change","level":"1.4.4","depth":2,"path":"lab2/step4.md","ref":"lab2/step4.md","articles":[]}]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"lab2/step1.md","mtime":"2020-07-21T05:06:54.163Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2020-07-21T05:17:37.657Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

